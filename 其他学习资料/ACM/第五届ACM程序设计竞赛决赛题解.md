A: a + b问题。 C++要写高精度，何不用Python？ 爽到飞起
```
n = int(input());
for i in range(n):
    a,b = input().split(' ');
    print(int(a) + int(b));
```


J: 由于有一边与x或y平行，所以只有1为底，2为高，1为高2为底这两种情况，，，然后你画一个简单的图，把他们表示出来，注意不要重复运算，然后为了取模，将它变为（ab）%c=（（a%c）（b%c））%c的格式，也就是因式分解，就完成了，详细一点为，比方说有一个mn的格点，x为m，y方向n个，我们以2为底，平行于x轴，那么在m个格点里我们共有m-2个2，（比如三个格点只有一个2），那么它所有的上面一行的m个点，都可以构成好三角形，有m个，最上面一行无法向上构成，因而又（n-1）行，又，可以从上往下画三角形，同理，也是n-1行，每行有m-2个2，每个2对应m个点。然后这种三角形我们平行y轴，将刚刚式子，m和n对调即可。对于底为1，高为2的情况，同理每行有m-1个1，每个1对应m-2个点（这里减去两个是为了把和平行y轴，底为2的重复的去掉），显然有n-2行，上下再2，m、n再对调，加起来即为总和，因式分解到能够取模的地步，完成。
```
#include<bits/stdc++.h>
using namespace std;
long long n,m;
const int N = 1e9+7; 
int main(){
	cin >> n >> m ;
	cout<<(((n-2)*(m-1)%N+ (n-1)*(m-2)%N )%N *2*(m+n -2)%N)%N<<endl;
	return 0;	
}
```
